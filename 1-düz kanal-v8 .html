<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<title>Three.js – Düz Kanal (mobil HUD %50 + tek sıra yön tuşları)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<style>
  :root{
    --bg:#ffffff; --panel:#f6f8fb; --text:#111418; --muted:#d0d7de;
    --blue:#1e5bff; --minus:#ff6b6b; --plus:#2ecc71;
    --uiScale:1; /* masaüstü */
  }
  @media (max-width:600px){ :root{ --uiScale:.8; } }  /* mobil %50 */

  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text)}
  body{overflow:hidden;font:13px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}

  /* Ana konteyner - 3 bölüm grid */
  #app{height:100vh;display:grid;grid-template-rows:auto 1fr auto;gap:0}
  
  /* HUD bilgi kutusu - üst */
  #hudContainer{
    background:var(--panel);border-bottom:1px solid var(--muted);
    padding:8px;display:flex;align-items:center;justify-content:center;
    position:relative;z-index:15;
  }
  
  /* 3D Sahne - orta (büyük alan) */
  #sceneWrap{
    position:relative;background:var(--bg);
    min-height:60vh;flex:1 1 auto;
  }
  
  /* GUI Kontroller - alt */
  #panel{
    background:var(--panel);border-top:1px solid var(--muted);
    max-height:30vh;overflow:auto;
    flex:0 0 auto;
  }

  /* Desktop layout - yan yana */
  @media (min-width:900px){
    #app{grid-template-columns:300px 1fr 350px;grid-template-rows:1fr;
         grid-template-areas:"hud scene panel"}
    #hudContainer{grid-area:hud;border-bottom:none;border-right:1px solid var(--muted);
                  flex-direction:column;justify-content:flex-start;padding:12px}
    #sceneWrap{grid-area:scene;min-height:100vh}
    #panel{grid-area:panel;max-height:100vh;border-top:none;border-left:1px solid var(--muted)}
  }

  #c{display:block;width:100%;height:100%}

  /* HUD - artık ayrı bölümde */
  #hud{
    position:static;color:#1f2328;background:transparent;
    padding:4px 8px;font-size:12px;
    border:1px solid var(--muted); border-radius:8px;
    text-align:center;margin:0;
  }
  
  /* Mobilde HUD daha kompakt */
  @media (max-width:600px){
    #hud{font-size:10px;padding:2px 4px}
  }

  /* Yön butonları: TEK SIRA – wrap yok, taşarsa yatay kaydır */
  #viewbar{
    position:absolute; left:50%; bottom:10px; z-index:11;
    transform:translateX(-50%) scale(var(--uiScale)); transform-origin:bottom center;
    display:flex; flex-wrap:nowrap; gap:calc(8px*var(--uiScale));
    background:rgba(255,255,255,.85); border:1px solid var(--muted); border-radius:12px; backdrop-filter:blur(6px);
    padding:calc(6px*var(--uiScale)) calc(8px*var(--uiScale));
    max-width:calc(100% - 16px); overflow-x:auto; -webkit-overflow-scrolling:touch; scrollbar-width:thin;
  }
  #viewbar .vbtn{
    flex:0 0 auto; min-width:calc(64px*var(--uiScale));
    background:#fff;color:#1f2328;border:1px solid var(--muted);border-radius:8px;
    padding:calc(6px*var(--uiScale)) calc(10px*var(--uiScale));
    font-size:calc(12px*var(--uiScale)); cursor:pointer
  }
  #viewbar .vbtn:hover{background:#f6f8fb}

  /* Ölçü paneli de ölçeklensin */
  .dims{
    padding:calc(10px*var(--uiScale)) calc(12px*var(--uiScale)) calc(6px*var(--uiScale)) calc(12px*var(--uiScale));
    border-bottom:1px solid var(--muted); background:#fff; position:sticky; top:0; z-index:2;
    font-size:calc(13px*var(--uiScale));
    transform:scale(var(--uiScale)); transform-origin:top left;
    width:calc(100% / var(--uiScale));  /* scale sonrası genişliği görsel olarak dengele */
  }
  .dimrow{
    display:grid;
    grid-template-columns:
      calc(38px*var(--uiScale)) 1fr auto
      calc(72px*var(--uiScale)) auto calc(72px*var(--uiScale));
    gap:calc(8px*var(--uiScale)); align-items:center; margin:calc(8px*var(--uiScale)) 0;
  }
  .dimrow label{font-weight:700;justify-self:end}
  .dimrow input[type="range"]{width:100%;accent-color:var(--blue);transform:scale(var(--uiScale));transform-origin:left center}
  .dimrow .num{
    width:calc(72px*var(--uiScale));
    padding:calc(6px*var(--uiScale)) calc(8px*var(--uiScale));
    border:1px solid var(--muted); border-radius:calc(6px*var(--uiScale));
    background:#fff; text-align:center; font-weight:700;
    font-size:calc(13px*var(--uiScale));
  }
  .dimrow .unit{font-weight:700}
  .btn{
    border:none;border-radius:calc(8px*var(--uiScale));
    padding:calc(8px*var(--uiScale)) calc(10px*var(--uiScale));
    color:#fff;font-weight:800;cursor:pointer;font-size:calc(13px*var(--uiScale))
  }
  .btn.minus{background:var(--minus)} .btn.plus{background:var(--plus)}

  /* lil-gui de küçülsün */
  .lil-gui{position:static!important;width:100%!important;background:transparent!important;border:0!important;
           transform:scale(var(--uiScale)); transform-origin:top left; width:calc(100%/var(--uiScale))!important}
  .lil-gui .title{background:#eef2f7!important;color:#111!important;border-bottom:1px solid var(--muted)!important}
  .lil-gui.root>.children{padding:calc(8px*var(--uiScale))}
  .lil-gui .controller{border-color:#cdd6df!important}
  .lil-gui .controller .name{color:#1b222b!important}
  .label{font-weight:800;background:rgba(255,255,255,.9);padding:2px 6px;border:1px solid var(--muted);
         border-radius:6px;box-shadow:0 2px 6px rgba(0,0,0,.08)}
</style>

<script type="importmap">
{"imports":{
  "three":"/vendor/three/build/three.module.js",
  "three/addons/":"/vendor/three/examples/jsm/"
}}
</script>
</head>
<body>
<div id="app">
  <!-- 1. HUD Bilgi Kutusu -->
  <div id="hudContainer">
    <div style="background:rgba(255,255,255,0.95);padding:8px 12px;margin-bottom:8px;border-radius:8px;display:flex;align-items:center;gap:10px;border:1px solid var(--muted);">
      <a href="/" style="display:flex;align-items:center;">
        <img src="/logo23dductorder.png" alt="3D Duct Order Logo" style="height:30px;width:auto;">
      </a>
      <span style="color:#1f2328;font-weight:600;font-size:14px;">Düz Kanal v8</span>
    </div>
    <div id="hud">Sol tık: döndür • Sağ tık: kaydır • Tekerlek: zoom</div>
  </div>
  
  <!-- 2. 3D Sahne Kutusu -->
  <div id="sceneWrap">
    <canvas id="c"></canvas>
    <div id="viewbar">
      <button class="vbtn" data-v="Right">Right</button>
      <button class="vbtn" data-v="Left">Left</button>
      <button class="vbtn" data-v="Front">Front</button>
      <button class="vbtn" data-v="Back">Back</button>
      <button class="vbtn" data-v="Top">Top</button>
      <button class="vbtn" data-v="SW Iso">SW Iso</button>
      <button class="vbtn" data-v="NE Iso">NE Iso</button>
    </div>
  </div>
  
  <!-- 3. GUI Kontroller Kutusu -->
  <div id="panel"><div class="dims" id="dims"></div></div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
import GUI from '/vendor/lil-gui/lil-gui.esm.min.js';

/* === kurulum (değişmedi) === */
const sceneWrap=document.getElementById('sceneWrap');
const panel=document.getElementById('panel');
const dimsWrap=document.getElementById('dims');
const C=document.getElementById('c');

const R=new THREE.WebGLRenderer({canvas:C,antialias:true,alpha:false});
R.setClearColor(0xffffff,1);
R.physicallyCorrectLights=true;
R.outputColorSpace=THREE.SRGBColorSpace;
R.toneMapping=THREE.ACESFilmicToneMapping;
R.toneMappingExposure=1.15;
R.shadowMap.enabled=true;
R.shadowMap.type=THREE.PCFSoftShadowMap;

const S=new THREE.Scene();
const pmrem=new THREE.PMREMGenerator(R);
S.environment=pmrem.fromScene(new RoomEnvironment(R),0.04).texture;

const Cam=new THREE.PerspectiveCamera(45,1,0.01,1e5);
Cam.position.set(3.2,1.9,3.2); S.add(Cam);

const Hemi=new THREE.HemisphereLight(0xffffff,0xdfe3ea,.65); S.add(Hemi);
const Key=new THREE.DirectionalLight(0xffffff,1.2); Key.position.set(4,6,5);
Key.castShadow=true; Key.shadow.mapSize.set(2048,2048);
Key.shadow.camera.near=.1; Key.shadow.camera.far=50;
Key.shadow.camera.left=-10; Key.shadow.camera.right=10;
Key.shadow.camera.top=10; Key.shadow.camera.bottom=-10;
S.add(Key);

const Ctrl=new OrbitControls(Cam,R.domElement);
Ctrl.enableDamping=true;
Ctrl.zoomToCursor=false;
Ctrl.dollySpeed=0.9;

const Grid=new THREE.GridHelper(20,40,0xe6ebf1,0xf2f4f7); Grid.visible=false; S.add(Grid);
const Ax=new THREE.AxesHelper(1); Ax.visible=false; S.add(Ax);

const LBL=new CSS2DRenderer(); Object.assign(LBL.domElement.style,{position:'absolute',inset:'0',pointerEvents:'none'}); sceneWrap.appendChild(LBL.domElement);
const hud=document.getElementById('hud'); const areaEl=document.createElement('div'); areaEl.style.marginTop='6px'; hud.appendChild(areaEl);

/* Gruplar / model */
const G=new THREE.Group(), GF=new THREE.Group(), GD=new THREE.Group(), GROUND=new THREE.Group();
const MODEL=new THREE.Group(); MODEL.add(G,GF);
const ROOT=new THREE.Group(); ROOT.add(MODEL,GD,GROUND); S.add(ROOT);

/* Malzemeler */
const metalMat=new THREE.MeshPhysicalMaterial({color:0xb9c1c9,roughness:0.42,metalness:0.2,clearcoat:0.25,clearcoatRoughness:0.6,side:THREE.DoubleSide,envMapIntensity:0.8});
const flangeMat=new THREE.MeshStandardMaterial({color:0xaab2bb,roughness:0.5,metalness:0.15,side:THREE.DoubleSide,envMapIntensity:0.8});
const edgeMat=new THREE.LineBasicMaterial({color:0x6b7581});

/* Yardımcılar */
const V=(x=0,y=0,z=0)=>new THREE.Vector3(x,y,z);
const cm=v=>v*0.01;
const clear=g=>{while(g.children.length){const c=g.children.pop();c.geometry?.dispose?.();if(c.material){(Array.isArray(c.material)?c.material:[c.material]).forEach(m=>m.dispose?.());}}};
const addLabel=(txt,pos,color)=>{const d=document.createElement('div');d.className='label';d.textContent=txt;if(color)d.style.color=color;const o=new CSS2DObject(d);o.position.copy(pos);S.add(o);GD.add(o);return o;};
const arrowBoth=(p1,p2,color=0x1e5bff,head=0.04,rad=0.01)=>{const col=new THREE.Color(color);
  const ln=new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1,p2]),new THREE.LineBasicMaterial({color:col,depthTest:false,depthWrite:false,transparent:true}));ln.renderOrder=999;
  const dir=V().subVectors(p2,p1).normalize();
  const mk=(q,p)=>{const c=new THREE.Mesh(new THREE.ConeGeometry(rad,head,12),new THREE.MeshBasicMaterial({color:col,depthTest:false,depthWrite:false,transparent:true}));c.quaternion.copy(q);c.position.copy(p);c.renderOrder=999;return c;};
  const q2=new THREE.Quaternion().setFromUnitVectors(V(0,1,0),dir), q1=new THREE.Quaternion().setFromUnitVectors(V(0,1,0),dir.clone().negate()); GD.add(ln,mk(q2,p2),mk(q1,p1)); };
const dimLine=(p1,p2,offsetDir,label,lineColor)=>{const n=offsetDir.clone().normalize(),gap=cm(1);
  const targetOff=cm(20);const s1=p1.clone().add(n.clone().multiplyScalar(gap)),e1=p1.clone().add(n.clone().multiplyScalar(targetOff));
  const s2=p2.clone().add(n.clone().multiplyScalar(gap)),e2=p2.clone().add(n.clone().multiplyScalar(targetOff));
  const col=new THREE.Color(lineColor||0x1e5bff);
  const mat=new THREE.LineBasicMaterial({color:col,depthTest:false,depthWrite:false,transparent:true});
  const L1=new THREE.Line(new THREE.BufferGeometry().setFromPoints([s1,e1]),mat),L2=new THREE.Line(new THREE.BufferGeometry().setFromPoints([s2,e2]),mat);
  L1.renderOrder=L2.renderOrder=999;GD.add(L1,L2);
  const head=cm(4),rad=cm(1.2),dir=V().subVectors(e2,e1).normalize(),off=cm(1.5);
  const a1=e1.clone().add(dir.clone().multiplyScalar(off));const a2=e2.clone().add(dir.clone().multiplyScalar(-off));
  arrowBoth(a1,a2,col,head,rad);
  const mid=a1.clone().add(a2).multiplyScalar(0.5).add(n.clone().multiplyScalar(cm(0.5)));
  return addLabel(label,mid,col.getStyle());
};

/* Parametreler */
const P={ W1:65, H1:105, L:165,
  showEdges:true, showDims:true, showFlange:true, flangeLip:3,
  colorW1:'#2f67bc', colorH1:'#c32828', colorL:'#26b6c9',
  keepViewOnEdit:true, showAxis:false, showGrid:false,
  areaIncludeFlange:false, wastePercent:0, kFactor:1,
  showGround:true, shadowOpacity:0.25, fitPadding:1.12
};
let didInitialFrame=false;

/* İnşa */
function build(){
  [G,GF,GD,GROUND].forEach(clear);
  document.querySelectorAll('.label').forEach(e=>e.remove());

  const W=cm(P.W1), H=cm(P.H1), L=cm(P.L), lip=cm(P.flangeLip);

  const top=new THREE.Mesh(new THREE.PlaneGeometry(W,L),metalMat); top.rotation.x=-Math.PI/2; top.position.set(0, H/2, L/2); G.add(top);
  const bot=new THREE.Mesh(new THREE.PlaneGeometry(W,L),metalMat); bot.rotation.x=-Math.PI/2; bot.position.set(0,-H/2, L/2); G.add(bot);
  const right=new THREE.Mesh(new THREE.PlaneGeometry(L,H),metalMat); right.rotation.y= Math.PI/2; right.position.set( W/2,0,L/2); G.add(right);
  const left =new THREE.Mesh(new THREE.PlaneGeometry(L,H),metalMat); left.rotation.y =-Math.PI/2; left .position.set(-W/2,0,L/2); G.add(left);
  [top,bot,right,left].forEach(m=>{m.castShadow=true;m.receiveShadow=true;});
  if(P.showEdges){[top,bot,right,left].forEach(m=>{const e=new THREE.LineSegments(new THREE.EdgesGeometry(m.geometry),edgeMat);e.rotation.copy(m.rotation);e.position.copy(m.position);G.add(e);});}

  if(P.showFlange){
    const F0=flangeRing(W,H,lip); F0.position.set(0,0,0); GF.add(F0);
    const F1=flangeRing(W,H,lip); F1.position.set(0,0,L); GF.add(F1);
    [F0,F1].forEach(m=>{m.castShadow=true;m.receiveShadow=true;});
  }

  if(P.showGround){
    const box=getModelBox(); const sz=box.getSize(new THREE.Vector3());
    const gSize=Math.max(5, Math.max(sz.x,sz.z)*1.8);
    const gMat=new THREE.ShadowMaterial({opacity:P.shadowOpacity,color:0x000000});
    const ground=new THREE.Mesh(new THREE.PlaneGeometry(gSize,gSize),gMat);
    ground.rotation.x=-Math.PI/2; ground.position.y=-H/2-cm(0.5); ground.receiveShadow=true; GROUND.add(ground);
  }

  if(P.showDims){
    dimLine(V(-W/2, H/2, L), V(W/2, H/2, L), V(0,1,0),  `W1 = ${Math.round(P.W1)} cm`, P.colorW1);
    dimLine(V(-W/2,-H/2, L), V(-W/2, H/2, L), V(-1,0,0), `H1 = ${Math.round(P.H1)} cm`, P.colorH1);
    dimLine(V(W/2,-H/2, 0),  V(W/2,-H/2, L), V(1,0,0),  `L = ${Math.round(P.L)} cm`,  P.colorL);
  }

  const area=2*(W+H)*L, sheet=area*(P.kFactor??1), waste=sheet*(1+((P.wastePercent||0)/100));
  areaEl.textContent=`Yan Alan: ${area.toFixed(3)} m² | k=${(P.kFactor??1).toFixed(2)} ⇒ ${sheet.toFixed(3)} m² | +%${(P.wastePercent||0).toFixed(0)} atık ⇒ ${waste.toFixed(3)} m²`;

  fitView(MODEL,{padding:P.fitPadding, viewDir:null, preserveTarget: didInitialFrame, smooth: didInitialFrame});
  didInitialFrame=true;
}

/* Flanş halkası */
function flangeRing(Wm,Hm,lip){
  const sh=new THREE.Shape([new THREE.Vector2(-Wm/2-lip,-Hm/2-lip),new THREE.Vector2( Wm/2+lip,-Hm/2-lip),new THREE.Vector2( Wm/2+lip, Hm/2+lip),new THREE.Vector2(-Wm/2-lip, Hm/2+lip)]);
  const hole=new THREE.Path([new THREE.Vector2(-Wm/2,-Hm/2),new THREE.Vector2( Wm/2,-Hm/2),new THREE.Vector2( Wm/2, Hm/2),new THREE.Vector2(-Wm/2, Hm/2)]);
  sh.holes.push(hole);
  const g=new THREE.ShapeGeometry(sh); g.center();
  const m=new THREE.Mesh(g,flangeMat); m.add(new THREE.LineSegments(new THREE.EdgesGeometry(g),edgeMat));
  return m;
}
function getModelBox(){ return new THREE.Box3().expandByObject(MODEL); }

/* Kadraj */
function fitView(obj,{padding=1.25,viewDir=null,preserveTarget=true,smooth=true}={}){
  const box=new THREE.Box3().expandByObject(obj); if(!isFinite(box.min.x)||!isFinite(box.max.x)) return;
  const t=(preserveTarget?Ctrl.target.clone():box.getCenter(new THREE.Vector3()));
  const corners=[new THREE.Vector3(box.min.x,box.min.y,box.min.z),new THREE.Vector3(box.min.x,box.min.y,box.max.z),new THREE.Vector3(box.min.x,box.max.y,box.min.z),new THREE.Vector3(box.min.x,box.max.y,box.max.z),new THREE.Vector3(box.max.x,box.min.y,box.min.z),new THREE.Vector3(box.max.x,box.min.y,box.max.z),new THREE.Vector3(box.max.x,box.max.y,box.min.z),new THREE.Vector3(box.max.x,box.max.y,box.max.z)];
  let reff=0; for(const k of corners) reff=Math.max(reff,k.distanceTo(t));
  let dir; if(viewDir){dir=viewDir.clone().normalize();} else{ const cur=Cam.position.clone().sub(Ctrl.target); dir=cur.length()>1e-6?cur.normalize():new THREE.Vector3(1,0.8,1).normalize(); }
  const vfov=THREE.MathUtils.degToRad(Cam.fov), aspect=Math.max(0.0001,Cam.aspect||1), hfov=2*Math.atan(Math.tan(vfov/2)*aspect);
  const needDist=Math.max(reff/Math.tan(vfov/2), reff/Math.tan(hfov/2))*padding;
  const endTgt=t.clone(); const endPos=t.clone().add(dir.multiplyScalar(needDist));
  Ctrl.maxDistance=needDist*10; Ctrl.minDistance=Math.max(needDist*0.01,0.001);
  Cam.near=Math.max(needDist/200,0.001); Cam.far=needDist*80+reff*5; Cam.updateProjectionMatrix();
  if(!smooth||!didInitialFrame){ Ctrl.target.copy(endTgt); Cam.position.copy(endPos); Ctrl.update(); }
  else{ const sp=Cam.position.clone(), st=Ctrl.target.clone(), dur=280, t0=performance.now();
    (function anim(){ const a=(performance.now()-t0)/dur; if(a>=1){Ctrl.target.copy(endTgt); Cam.position.copy(endPos); Ctrl.update();}
      else{ const u=a<0.5?2*a*a:-1+(4-2*a)*a; Cam.position.lerpVectors(sp,endPos,u); Ctrl.target.lerpVectors(st,endTgt,u); Ctrl.update(); requestAnimationFrame(anim);} })();
  }
}

/* Ölçü girişleri */
function makeDimRow(label,key,min,max){
  const row=document.createElement('div'); row.className='dimrow';
  row.innerHTML=`<label>${label}:</label>
    <input class="slider" type="range" min="${min}" max="${max}" step="1">
    <button class="btn minus">-5</button>
    <input class="num" type="number" min="${min}" max="${max}" step="1">
    <span class="unit">cm</span>
    <button class="btn plus">+5</button>`;
  dimsWrap.appendChild(row);
  const slider=row.querySelector('.slider'), num=row.querySelector('.num'), minus=row.querySelector('.minus'), plus=row.querySelector('.plus');
  const clampInt=v=>Math.min(max,Math.max(min,Math.round(+v||0)));
  const setVal=v=>{v=clampInt(v); P[key]=v; slider.value=v; num.value=v; build();};
  slider.value=P[key]; num.value=P[key];
  slider.addEventListener('input',e=>setVal(e.target.value));
  num.addEventListener('input',e=>setVal(e.target.value));
  minus.addEventListener('click',()=>setVal(P[key]-5));
  plus .addEventListener('click',()=>setVal(P[key]+5));
  num.addEventListener('focus',()=>{num.select(); num.value='';});
  num.addEventListener('blur',()=>{ if(num.value==='') num.value=P[key]; });
}
makeDimRow('W1','W1',1,400);
makeDimRow('H1','H1',1,400);
makeDimRow('L','L',1,2000);

/* GUI */
const gui=new GUI({title:'Parametreler'}); panel.appendChild(gui.domElement);
const F1=gui.addFolder('Görünüm');
['showEdges','showDims','showFlange','showGround'].forEach(k=>F1.add(P,k).name({showEdges:'Kenar Çizgileri',showDims:'Ölçülendirme',showFlange:'Çift Flanş (2D)',showGround:'Zemin Gölgesi'}[k]).onChange(build));
F1.add(P,'shadowOpacity',0,1,0.01).name('Gölge Yoğunluğu').onChange(build);
F1.add(P,'fitPadding',1.05,1.50,0.01).name('Fit Boşluğu').onChange(()=>fitView(MODEL,{padding:P.fitPadding,preserveTarget:true,smooth:true}));
F1.add(P,'keepViewOnEdit').name('Yönü Koru');
const Fclr=gui.addFolder('Renkler');
[['colorW1','W1 Rengi'],['colorH1','H1 Rengi'],['colorL','L Rengi']].forEach(p=>Fclr.addColor(P,p[0]).name(p[1]).onChange(build));

/* Başlat / Resize */
function resizeToContainer(){
  const r=sceneWrap.getBoundingClientRect();
  const w=Math.max(1,Math.floor(r.width)), h=Math.max(1,Math.floor(r.height));
  R.setSize(w,h,false); LBL.setSize(w,h);
  Cam.aspect=w/h||1; Cam.updateProjectionMatrix();
  fitView(MODEL,{preserveTarget:true,smooth:false,padding:P.fitPadding});
}
addEventListener('resize',resizeToContainer);
addEventListener('orientationchange',()=>setTimeout(resizeToContainer,50));
resizeToContainer(); build();

/* Yön butonları */
const views={'Right':new THREE.Vector3(1,0,0),'Left':new THREE.Vector3(-1,0,0),'Front':new THREE.Vector3(0,0,1),'Back':new THREE.Vector3(0,0,-1),'Top':new THREE.Vector3(0,1,0),'SW Iso':new THREE.Vector3(-1,1,-1),'NE Iso':new THREE.Vector3(1,1,1)};
document.getElementById('viewbar')?.querySelectorAll('.vbtn').forEach(b=>b.addEventListener('click',()=>{
  const d=views[b.dataset.v]; if(d) fitView(MODEL,{viewDir:d,preserveTarget:true,smooth:true,padding:P.fitPadding});
}));

/* Render döngüsü */
(function anim(){ requestAnimationFrame(anim); Ctrl.update(); R.render(S,Cam); LBL.render(S,Cam); })();
</script>
</body>
</html>
