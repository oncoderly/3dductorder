<!DOCTYPE html><html lang="tr"><head><meta charset="utf-8"/>
<title>Three.js – Kareden Yuvarlağa Geçiş (cm) • Şablon</title>
<style>html,body{height:100%;margin:0;overflow:hidden;background:#0b0e12}#hud{position:absolute;top:10px;left:10px;z-index:10;color:#e6edf3;font:13px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}.label{color:inherit;font-weight:700;text-shadow:0 0 2px #000}</style>
<script type="importmap">{"imports":{"three":"/vendor/three/build/three.module.js","three/addons/":"/vendor/three/examples/jsm/"}}</script>
</head><body>
<div style="position:absolute;top:10px;left:10px;z-index:100;background:rgba(18,24,34,0.9);padding:8px 12px;border-radius:8px;display:flex;align-items:center;gap:10px;border:1px solid #39414f;">
  <a href="/" style="display:flex;align-items:center;">
    <img src="/logo23dductorder.png" alt="3D Duct Order Logo" style="height:30px;width:auto;">
  </a>
  <span style="color:#e6edf3;font-weight:600;font-size:14px;">Kareden Yuvarlağa</span>
</div>
<div id="hud">Sol tık: döndür • Sağ tık: kaydır • Tekerlek: zoom</div>
<canvas id="c"></canvas>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
import GUI from '/vendor/lil-gui/lil-gui.esm.min.js';

// ===== KURULUM =====
const C=document.getElementById('c');
const R=new THREE.WebGLRenderer({canvas:C,antialias:true,alpha:true});
R.setSize(innerWidth,innerHeight); R.setPixelRatio(Math.min(2,devicePixelRatio));
const S=new THREE.Scene();
const Cam=new THREE.PerspectiveCamera(45,innerWidth/innerHeight,0.01,1e4); Cam.position.set(3.2,1.9,3.2); S.add(Cam);
S.add(new THREE.HemisphereLight(0xffffff,0x101018,0.9)); const DL=new THREE.DirectionalLight(0xffffff,0.7); DL.position.set(3,5,4); S.add(DL);
const Ctrl=new OrbitControls(Cam,R.domElement); Ctrl.enableDamping=true;
const Grid=new THREE.GridHelper(10,20,0x2a2e35,0x1a1d23); S.add(Grid);
const Ax=new THREE.AxesHelper(1); S.add(Ax);
const LBL=new CSS2DRenderer(); LBL.setSize(innerWidth,innerHeight); Object.assign(LBL.domElement.style,{position:'absolute',top:'0',pointerEvents:'none'}); document.body.appendChild(LBL.domElement);
const hud=document.getElementById('hud'); const areaEl=document.createElement('div'); areaEl.style.marginTop='6px'; hud.appendChild(areaEl);

// ===== PARAM =====
const P={ W1:100, H1:80, Phi:60, L:120, t:0.12, steps:120, edgeSegs:12,
  showEdges:true, showDims:true, showFlange:true,
  flangeLip:3, flangeThick:0.6,
  metalRough:0.35, metalness:0.85,
  showAxis:false, showGrid:true,
  dimOffsetCm:1.5, arrowHeadCm:4, arrowRadiusCm:1.2,
  extLenCm:15, extGapCm:1, dimPlaneOffsetCm:20, labelOffsetCm:0.5,
  showSideLabels:true, dimAlwaysOnTop:true, dimFixedOffset:true,
  colorW1:'#007bff', colorH1:'#ffd400', colorPhi:'#00c853', colorL:'#00bcd4',
  areaIncludeFlange:false, wastePercent:25, kFactor:1,
  // Ofset modu
  modeW:'flatRight', modeH:'central', offWcm:0, offHcm:0 };

// ===== MALZEME & GRUP =====
const metalMat=new THREE.MeshPhysicalMaterial({color:0xbfc7d2,roughness:P.metalRough,metalness:P.metalness,clearcoat:0.5,clearcoatRoughness:0.25,side:THREE.DoubleSide});
const flangeMat=new THREE.MeshPhysicalMaterial({color:0x9aa3ad,roughness:0.6,metalness:0.9});
const edgeMat=new THREE.LineBasicMaterial({color:0x3a3f46});
const G=new THREE.Group(), GF=new THREE.Group(), GD=new THREE.Group(); S.add(G,GF,GD);

// ===== Yardımcılar =====
const V=(x=0,y=0,z=0)=>new THREE.Vector3(x,y,z);
const cm=v=>v*0.01;
const clear=g=>{ while(g.children.length){ const c=g.children.pop(); c.geometry?.dispose?.(); if(c.material){ (Array.isArray(c.material)?c.material:[c.material]).forEach(m=>m.dispose?.()); } } };
const addLabel=(txt,pos,color)=>{ const d=document.createElement('div'); d.className='label'; d.textContent=txt; if(color) d.style.color=color; const o=new CSS2DObject(d); o.position.copy(pos); S.add(o); GD.add(o); return o; };
const arrowBoth=(p1,p2,color=0xff4d4d,head=0.04,rad=0.01)=>{ const ln=new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1,p2]), new THREE.LineBasicMaterial({color,depthTest:!P.dimAlwaysOnTop,depthWrite:!P.dimAlwaysOnTop,transparent:P.dimAlwaysOnTop})); ln.renderOrder=P.dimAlwaysOnTop?999:0; const dir=V().subVectors(p2,p1).normalize(); const mk=(q,p)=>{ const c=new THREE.Mesh(new THREE.ConeGeometry(rad,head,12), new THREE.MeshBasicMaterial({color,depthTest:!P.dimAlwaysOnTop,depthWrite:!P.dimAlwaysOnTop,transparent:P.dimAlwaysOnTop})); c.quaternion.copy(q); c.position.copy(p); c.renderOrder=P.dimAlwaysOnTop?999:0; return c; }; const q2=new THREE.Quaternion().setFromUnitVectors(V(0,1,0),dir), q1=new THREE.Quaternion().setFromUnitVectors(V(0,1,0),dir.clone().negate()); GD.add(ln, mk(q2,p2), mk(q1,p1)); };
const dimLine=(p1,p2,offsetDir,label,color)=>{ const n=offsetDir.clone().normalize(), gap=cm(P.extGapCm); const targetOff=P.dimFixedOffset? cm(P.dimPlaneOffsetCm) : (gap+cm(P.extLenCm)); const s1=p1.clone().add(n.clone().multiplyScalar(gap)), e1=p1.clone().add(n.clone().multiplyScalar(targetOff)); const s2=p2.clone().add(n.clone().multiplyScalar(gap)), e2=p2.clone().add(n.clone().multiplyScalar(targetOff)); const mat=new THREE.LineBasicMaterial({color:new THREE.Color(color||0xff4d4d),depthTest:!P.dimAlwaysOnTop,depthWrite:!P.dimAlwaysOnTop,transparent:P.dimAlwaysOnTop}); const L1=new THREE.Line(new THREE.BufferGeometry().setFromPoints([s1,e1]),mat), L2=new THREE.Line(new THREE.BufferGeometry().setFromPoints([s2,e2]),mat); L1.renderOrder=L2.renderOrder=P.dimAlwaysOnTop?999:0; GD.add(L1,L2); const head=cm(P.arrowHeadCm), rad=cm(P.arrowRadiusCm), dir=V().subVectors(e2,e1).normalize(), off=cm(P.dimOffsetCm); const a1=e1.clone().add(dir.clone().multiplyScalar(off)), a2=e2.clone().add(dir.clone().multiplyScalar(-off)); arrowBoth(a1,a2,color,head,rad); const mid=a1.clone().add(a2).multiplyScalar(0.5).add(n.clone().multiplyScalar(cm(P.labelOffsetCm))); return addLabel(label, mid, color); };
const triA=(a,b,c)=>{ const ab=V().subVectors(b,a), ac=V().subVectors(c,a); return ab.cross(ac).length()*0.5; };
const flangeRect=(Wm,Hm,lip,th)=>{ const sh=new THREE.Shape([ new THREE.Vector2(-Wm/2-lip,-Hm/2-lip), new THREE.Vector2(Wm/2+lip,-Hm/2-lip), new THREE.Vector2(Wm/2+lip,Hm/2+lip), new THREE.Vector2(-Wm/2-lip,Hm/2+lip) ]); const hole=new THREE.Path([ new THREE.Vector2(-Wm/2,-Hm/2), new THREE.Vector2(Wm/2,-Hm/2), new THREE.Vector2(Wm/2,Hm/2), new THREE.Vector2(-Wm/2,Hm/2) ]); sh.holes.push(hole); const g=new THREE.ExtrudeGeometry(sh,{depth:th,bevelEnabled:false}); g.center(); const m=new THREE.Mesh(g, flangeMat); m.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), edgeMat)); return m; };
const flangeRound=(D,lip,th)=>{ const Rr=D/2; const sh=new THREE.Shape(); sh.absarc(0,0,Rr+lip,0,Math.PI*2,false); const hole=new THREE.Path(); hole.absarc(0,0,Rr,0,Math.PI*2,true); sh.holes.push(hole); const g=new THREE.ExtrudeGeometry(sh,{depth:th,bevelEnabled:false}); g.center(); const m=new THREE.Mesh(g, flangeMat); m.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), edgeMat)); return m; };

// Eşit aralıklı dikdörtgen ve çember noktaları
function rectEven(N, hx, hy){ const Pm=4*(hx+hy); const pts=[]; for(let k=0;k<N;k++){ let s=Pm*k/N; if(s<2*hx){ pts.push(new THREE.Vector3(-hx+s,-hy,0)); }
  else if((s-=2*hx)<2*hy){ pts.push(new THREE.Vector3(hx,-hy+s,0)); }
  else if((s-=2*hy)<2*hx){ pts.push(new THREE.Vector3(hx-s,hy,0)); }
  else { s-=2*hx; pts.push(new THREE.Vector3(-hx,hy-s,0)); } } return pts; }
function circleEven(N, r){ const pts=[]; for(let k=0;k<N;k++){ const th=-3*Math.PI/4 + 2*Math.PI*k/N; pts.push(new THREE.Vector3(r*Math.cos(th), r*Math.sin(th), 0)); } return pts; }

// ===== Ana İnşa =====
function build(){
  try{
    clear(G); clear(GF); clear(GD); document.querySelectorAll('.label').forEach(e=>e.remove());
    const W1=cm(P.W1), H1=cm(P.H1), D=cm(P.Phi), L=cm(P.L), t=cm(P.t), lip=cm(P.flangeLip), fth=cm(P.flangeThick);
    const n=V(1,0,0), b=V(0,1,0), tz=V(0,0,1);
    const per=Math.max(4,Math.floor(P.edgeSegs)); const N=per; // noktalar halka başına
    // Baş ve son kesit noktaları (outer/inner)
    const rectO=rectEven(N, W1/2, H1/2), rectI=rectEven(N, Math.max(W1/2-t,1e-5), Math.max(H1/2-t,1e-5));
    const circO=circleEven(N, D/2),     circI=circleEven(N, Math.max(D/2-t,1e-5));
    // Merkez ofset fonksiyonları (genişlik/height interpolasyonuna göre)
    const Wu=u=>W1*(1-u)+D*u, Hu=u=>H1*(1-u)+D*u;
    const left0=-W1/2, right0=W1/2, bottom0=-H1/2, top0=H1/2;
    const offWx=cm(P.offWcm), offHy=cm(P.offHcm);
    const cx=(u)=> P.modeW==='flatLeft'  ? left0 + Wu(u)/2 :
                   P.modeW==='flatRight' ? right0 - Wu(u)/2 :
                   P.modeW==='value'     ? offWx*u : 0;
    const cy=(u)=> P.modeH==='flatBottom'? bottom0 + Hu(u)/2 :
                   P.modeH==='flatTop'   ? top0    - Hu(u)/2 :
                   P.modeH==='value'     ? offHy*u : 0;

    // Halka örme
    const vs=[], idx=[]; const Rout=[], Rin=[];
    for(let i=0;i<=P.steps;i++){
      const u=i/P.steps;
      const O=[], I=[];
      for(let k=0;k<N;k++){
        const po=rectO[k].clone().multiplyScalar(1-u).add(circO[k].clone().multiplyScalar(u));
        const pi=rectI[k].clone().multiplyScalar(1-u).add(circI[k].clone().multiplyScalar(u));
        po.x+=cx(u); po.y+=cy(u); po.z=u*L;
        pi.x+=cx(u); pi.y+=cy(u); pi.z=u*L;
        O.push(po); I.push(pi);
      }
      Rout.push(O); Rin.push(I);
    }
    const push=r=>{for(const v of r){vs.push(v.x,v.y,v.z)}};
    for(let i=0;i<=P.steps;i++) push(Rout[i]); const innerBase=vs.length/3; for(let i=0;i<=P.steps;i++) push(Rin[i]);
    const quad=(a,b,c,d)=>{idx.push(a,b,c, a,c,d)};
    for(let i=0;i<P.steps;i++){ const b0=i*N, b1=(i+1)*N; for(let k=0;k<N;k++){ const a=b0+k, bI=b0+(k+1)%N, c=b1+(k+1)%N, d=b1+k; quad(a,bI,c,d); } }
    for(let i=0;i<P.steps;i++){ const b0=innerBase+i*N, b1=innerBase+(i+1)*N; for(let k=0;k<N;k++){ const a=b0+k, bI=b0+(k+1)%N, c=b1+(k+1)%N, d=b1+k; quad(d,c,bI,a); } }
    const geo=new THREE.BufferGeometry(); geo.setAttribute('position',new THREE.Float32BufferAttribute(vs,3)); geo.setIndex(idx); geo.computeVertexNormals();
    const msh=new THREE.Mesh(geo, metalMat); G.add(msh); if(P.showEdges) G.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo,1),edgeMat));

    // Alan (dış yüzey)
    let Aout=0; for(let i=0;i<P.steps;i++){ const r0=Rout[i], r1=Rout[i+1]; for(let k=0;k<N;k++){ const v00=r0[k], v01=r0[(k+1)%N], v11=r1[(k+1)%N], v10=r1[k]; Aout+=triA(v00,v01,v11)+triA(v00,v11,v10); } }
    let sheet = Aout * (P.kFactor ?? 1);
    if(P.areaIncludeFlange){ GF.children.forEach(m=>{ if(m.geometry){ const g=m.geometry, p=g.attributes.position.array, I=g.index?g.index.array:null; let A=0; const a=V(), b2=V(), c2=V(); const read=(i,o)=>o.set(p[3*i],p[3*i+1],p[3*i+2]); if(I){ for(let i=0;i<I.length;i+=3){ read(I[i],a); read(I[i+1],b2); read(I[i+2],c2); A += triA(a,b2,c2);} } else { for(let i=0;i<p.length;i+=9){ a.set(p[i],p[i+1],p[i+2]); b2.set(p[i+3],p[i+4],p[i+5]); c2.set(p[i+6],p[i+7],p[i+8]); A+=triA(a,b2,c2);} } sheet+=A; } }); }
    const waste=sheet*(1+((P.wastePercent||0)/100));

    // Flanşlar
    if(P.showFlange){
      const p0=V(cx(0),cy(0),0), p1=V(cx(1),cy(1),L);
      const F0=flangeRect(W1,H1,lip,fth); const F1=flangeRound(D,lip,fth);
      const place=(o,p,t,n,b)=>{ const M=new THREE.Matrix4().makeBasis(n.clone(),b.clone(),t.clone()); const Q=new THREE.Quaternion().setFromRotationMatrix(M); o.position.copy(p); o.quaternion.copy(Q); };
      place(F0, p0.clone().add(tz.clone().multiplyScalar(-fth*0.5)), tz, n, b);
      place(F1, p1.clone().add(tz.clone().multiplyScalar( fth*0.5)),  tz, n, b);
      GF.add(F0,F1);
    }

    // Ölçülendirme
    if(P.showDims){
      const p0=V(cx(0),cy(0),0), p1=V(cx(1),cy(1),L);
      // Sol (kare)
      const x0L=n.clone().multiplyScalar(-W1/2), x0R=n.clone().multiplyScalar(W1/2), y0T=b.clone().multiplyScalar(H1/2), y0B=b.clone().multiplyScalar(-H1/2);
      dimLine(p0.clone().add(x0L).add(y0T), p0.clone().add(x0R).add(y0T), b, `W1 = ${P.W1.toFixed(1)} cm`, P.colorW1);
      dimLine(p0.clone().add(x0R).add(y0B), p0.clone().add(x0R).add(y0T), n, `H1 = ${P.H1.toFixed(1)} cm`, P.colorH1);
      // Sağ (daire çapı)
      const Rr=D/2; const xR=n.clone().multiplyScalar(Rr);
      dimLine(p1.clone().add(xR.clone().negate()), p1.clone().add(xR), b, `Ø = ${P.Phi.toFixed(1)} cm`, P.colorPhi);
      // L
      const left0=p0.x-W1/2, left1=p1.x-D/2, bottom0=p0.y-H1/2, bottom1=p1.y-D/2; const xr=Math.max(left0,left1), yr=Math.max(bottom0,bottom1);
      dimLine(V(xr,yr,0), V(xr,yr,L), n.clone().negate(), `L = ${P.L.toFixed(1)} cm`, P.colorL);
    }

    // Yüz etiketleri (kare tarafı referans)
    if(P.showSideLabels){ const mid=V(cx(0.25), cy(0.25), L*0.5); const ox=W1*0.25, oy=H1*0.25; ['SAĞ','SOL','ÜST','ALT']
      .map((t,i)=>addLabel(t,[ mid.clone().add(n.clone().multiplyScalar( ox)), mid.clone().add(n.clone().multiplyScalar(-ox)), mid.clone().add(b.clone().multiplyScalar( oy)), mid.clone().add(b.clone().multiplyScalar(-oy)) ][i]))
      .forEach(e=>{ e.element.style.color = '#6cf'; }); }

    // Kadraj & HUD
    (function frame(o){ const box=new THREE.Box3().setFromObject(o); const size=box.getSize(new THREE.Vector3()); const ctr=box.getCenter(new THREE.Vector3()); const md=Math.max(size.x,size.y,size.z); const dist=md/(2*Math.tan(THREE.MathUtils.degToRad(Cam.fov/2)))*1.4; const dir=V(1,0.6,1).normalize(); Cam.position.copy(ctr.clone().add(dir.multiplyScalar(dist))); Cam.near=dist/100; Cam.far=dist*100; Cam.updateProjectionMatrix(); Ctrl.target.copy(ctr); Ctrl.update(); })(G);

    areaEl.textContent = `Dış: ${Aout.toFixed(3)} m² | k=${(P.kFactor??1).toFixed(2)} ⇒ ${sheet.toFixed(3)} m² | +%${(P.wastePercent||0).toFixed(1)} atık ⇒ ${waste.toFixed(3)} m²`;
    Ax.visible=P.showAxis; Grid.visible=P.showGrid;
  }catch(err){ console.error('[BUILD ERROR]',err); areaEl.textContent='Hata: '+err.message; }
}

// ===== Başlat =====
build();

// ===== GUI =====
const gui=new GUI({title:'Parametreler'});
const add=(f,o,k,min,max,step,name)=>f.add(o,k,min,max,step).name(name).onChange(build);
const F1=gui.addFolder('Ölçüler (cm)');
[ ['W1',1,400,0.1,'W1 (kare) cm'], ['H1',1,400,0.1,'H1 (kare) cm'], ['Phi',1,400,0.1,'Ø (daire) cm'], ['L',1,1000,0.1,'L (uzunluk) cm'], ['t',0.02,1,0.01,'Sac Kalınlığı t'], ['steps',8,400,1,'Yol Segmenti (steps)'], ['edgeSegs',8,96,1,'Halka Noktası (N)'] ].forEach(p=>add(F1,P,p[0],p[1],p[2],p[3],p[4]));

const F2=gui.addFolder('Görünüm / Flanş');
['showEdges','showDims','showFlange'].forEach(k=>F2.add(P,k).name({showEdges:'Kenar Çizgileri',showDims:'Ölçülendirme',showFlange:'Flanşları Göster'}[k]).onChange(build));
add(F2,P,'flangeLip',0.5,8,0.1,'Flanş Payı (lip) cm'); add(F2,P,'flangeThick',0.2,2,0.05,'Flanş Kalınlığı cm');
F2.add(P,'metalRough',0,1,0.01).name('Roughness').onChange(()=>{ metalMat.roughness=P.metalRough; R.render(S,Cam); });
F2.add(P,'metalness',0,1,0.01).name('Metalness').onChange(()=>{ metalMat.metalness=P.metalness; R.render(S,Cam); });
F2.add(P,'showAxis').name('Eksenleri Göster').onChange(v=>Ax.visible=v);
F2.add(P,'showGrid').name('Grid Göster').onChange(v=>Grid.visible=v);
F2.add(P,'dimAlwaysOnTop').name('Ölçüler hep üstte').onChange(build);
F2.add(P,'dimFixedOffset').name('Flanştan sabit uzaklık').onChange(build);
[ ['dimOffsetCm',0.5,5,0.1,'Ok Ucu Kısalt (cm)'], ['arrowHeadCm',1,8,0.1,'Ok Boyu (cm)'], ['arrowRadiusCm',0.5,3,0.1,'Ok Kalınlığı (cm)'], ['extLenCm',2,40,0.5,'Uzatma Uzunluğu (cm)'], ['extGapCm',0.2,5,0.1,'Parça Boşluğu (cm)'], ['dimPlaneOffsetCm',1,100,0.5,'Flanştan Mesafe (cm)'], ['labelOffsetCm',0,5,0.1,'Etiket Ofset (cm)'] ].forEach(p=>add(F2,P,p[0],p[1],p[2],p[3],p[4]));

const F3=gui.addFolder('Renkler');
[ ['colorW1','W1 Rengi'], ['colorH1','H1 Rengi'], ['colorPhi','Ø Rengi'], ['colorL','L Rengi'] ].forEach(p=>F3.addColor(P,p[0]).name(p[1]).onChange(build));

const FA=gui.addFolder('Alan Hesabı');
FA.add(P,'areaIncludeFlange').name('Flanşları dahil et').onChange(build);
FA.add(P,'wastePercent',0,100,1).name('% Atık/Pay').onChange(build);
FA.add(P,'kFactor',0,2,0.01).name('Düzeltme Katsayısı k').onChange(build);

// Ofset kontrolleri
const FO=gui.addFolder('Ofset');
FO.add(P,'modeW',{'Sol Düz':'flatLeft','Merkezi':'central','Sağ Düz':'flatRight','Değer':'value'}).name('Ofset-Genişlik').onChange(build);
FO.add(P,'offWcm',-200,200,0.1).name('Ofset-Genişlik (cm)').onChange(build);
FO.add(P,'modeH',{'Alt Düz':'flatBottom','Merkezi':'central','Üst Düz':'flatTop','Değer':'value'}).name('Ofset-Yükseklik').onChange(build);
FO.add(P,'offHcm',-200,200,0.1).name('Ofset-Yükseklik (cm)').onChange(build);

// ===== Döngü =====
addEventListener('resize',()=>{ Cam.aspect=innerWidth/innerHeight; Cam.updateProjectionMatrix(); R.setSize(innerWidth,innerHeight); LBL.setSize(innerWidth,innerHeight); });
(function anim(){ requestAnimationFrame(anim); Ctrl.update(); R.render(S,Cam); LBL.render(S,Cam); })();

// ===== TEST =====
(function T(){ const t=(n,c)=>console[c?'log':'error'](`[TEST] ${c?'PASS':'FAIL'} - ${n}`); t('Renderer',!!R.domElement); const o=P.W1; P.W1=o+0.1; build(); t('Rebuild',G.children.length>0); P.W1=o; build(); t('HUD',/m²/.test(areaEl.textContent)); t('Dims group',GD.children.length>=2); })();
</script></body></html>
