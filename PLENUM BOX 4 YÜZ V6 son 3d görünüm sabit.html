<!DOCTYPE html><html lang="tr"><head><meta charset="utf-8"/>
<title>Three.js – Çoklu Yüz Manşonları (v4)</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#0b0e12}
  #hud{position:absolute;top:10px;left:10px;z-index:10;color:#e6edf3;font:13px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .label{color:inherit;font-weight:700;background:rgba(18,24,34,.9);padding:4px 8px;border:1px solid #39414f;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.35);text-shadow:none}
  #viewbar{position:absolute;left:50%;transform:translateX(-50%);bottom:10px;display:flex;gap:6px;z-index:11}
  #viewbar .vbtn{background:#1b2230;color:#e6edf3;border:1px solid #39414f;border-radius:6px;padding:6px 10px;font:12px system-ui;cursor:pointer;opacity:.9}
  #viewbar .vbtn:hover{opacity:1}
</style>
<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"}}</script>
</head><body>
<div style="position:absolute;top:10px;left:10px;z-index:100;background:rgba(18,24,34,0.9);padding:8px 12px;border-radius:8px;display:flex;align-items:center;gap:10px;border:1px solid #39414f;">
  <a href="/" style="display:flex;align-items:center;">
    <img src="/logo23dductorder.png" alt="3D Duct Order Logo" style="height:30px;width:auto;">
  </a>
  <span style="color:#e6edf3;font-weight:600;font-size:14px;">Plenum Box V6</span>
</div>
<div id="hud">Sol tık: döndür • Sağ tık: kaydır • Tekerlek: zoom</div>
<canvas id="c"></canvas>
<div id="viewbar">
  <button class="vbtn" data-v="Right">Right</button>
  <button class="vbtn" data-v="Left">Left</button>
  <button class="vbtn" data-v="Front">Front</button>
  <button class="vbtn" data-v="Back">Back</button>
  <button class="vbtn" data-v="Top">Top</button>
  <button class="vbtn" data-v="SW Iso">SW Iso</button>
  <button class="vbtn" data-v="NE Iso">NE Iso</button>
</div>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

// === Temel kurulum ===
const C=document.getElementById('c');
const R=new THREE.WebGLRenderer({canvas:C,antialias:true,alpha:true});
R.setSize(innerWidth,innerHeight); R.setPixelRatio(Math.min(2,devicePixelRatio));
const S=new THREE.Scene();
const Cam=new THREE.PerspectiveCamera(45,innerWidth/innerHeight,0.01,1e4); Cam.position.set(3.2,1.9,3.2); S.add(Cam);
S.add(new THREE.HemisphereLight(0xffffff,0x101018,0.9)); const DL=new THREE.DirectionalLight(0xffffff,0.7); DL.position.set(3,5,4); S.add(DL);
const Ctrl=new OrbitControls(Cam,R.domElement); Ctrl.enableDamping=true;
const Grid=new THREE.GridHelper(10,20,0x2a2e35,0x1a1d23); S.add(Grid);
const Ax=new THREE.AxesHelper(1); S.add(Ax);
const LBL=new CSS2DRenderer(); LBL.setSize(innerWidth,innerHeight); Object.assign(LBL.domElement.style,{position:'absolute',top:'0',pointerEvents:'none'}); document.body.appendChild(LBL.domElement);
const hud=document.getElementById('hud'); const areaEl=document.createElement('div'); areaEl.style.marginTop='6px'; hud.appendChild(areaEl);
const viewbar=document.getElementById('viewbar');
let lastCtr=new THREE.Vector3(); let lastDist=3; let didInitialFrame=false;
const views={ 'Right':new THREE.Vector3(1,0,0),'Left':new THREE.Vector3(-1,0,0),'Front':new THREE.Vector3(0,0,1),'Back':new THREE.Vector3(0,0,-1),'Top':new THREE.Vector3(0,1,0),'SW Iso':new THREE.Vector3(-1,1,-1),'NE Iso':new THREE.Vector3(1,1,1)};
function setView(dir){ const v=dir.clone().normalize().multiplyScalar(lastDist); Cam.position.copy(lastCtr.clone().add(v)); Cam.near=lastDist/100; Cam.far=lastDist*100; Cam.updateProjectionMatrix(); Ctrl.target.copy(lastCtr); Ctrl.update(); }
viewbar?.querySelectorAll('.vbtn').forEach(b=>b.addEventListener('click',()=>{ const v=views[b.dataset.v]; if(v) setView(v); }));

// === Parametreler ===
const P={ W1:100, H1:80, L:120, Phi:60, spigotLenCm:10, t:0.12, steps:80,
  showEdges:true, showDims:true, showFlange:true,
  flangeLip:3, flangeThick:0.6,
  metalRough:0.35, metalness:0.85,
  showAxis:false, showGrid:true, keepViewOnEdit:true,
  dimOffsetCm:1.5, arrowHeadCm:4, arrowRadiusCm:1.2,
  extLenCm:15, extGapCm:1, dimPlaneOffsetCm:20, labelOffsetCm:0.5,
  showSideLabels:true, dimAlwaysOnTop:true, dimFixedOffset:true,
  colorW1:'#3ea2ff', colorH1:'#ffd400', colorL:'#00bcd4', colorPhi:'#00c853',
  areaIncludeFlange:false, wastePercent:25, kFactor:1,
  modeW:'central', modeH:'central', offWcm:0, offHcm:0,
  faces: {
    right: { count:1, ports:[{diam:60}] },
    left:  { count:0, ports:[] },
    front: { count:0, ports:[] },
    back:  { count:0, ports:[] },
    top:   { count:0, ports:[] }
  }
};

const metalMat=new THREE.MeshPhysicalMaterial({color:0xbfc7d2,roughness:P.metalRough,metalness:P.metalness,clearcoat:0.5,clearcoatRoughness:0.25,side:THREE.DoubleSide});
const flangeMat=new THREE.MeshPhysicalMaterial({color:0x9aa3ad,roughness:0.6,metalness:0.9});
const edgeMat=new THREE.LineBasicMaterial({color:0x3a3f46});
const G=new THREE.Group(), GF=new THREE.Group(), GD=new THREE.Group(); S.add(G,GF,GD);
[G,GF,GD].forEach(gr=>gr.rotation.x=Math.PI/2); // Ön yüz aşağı -Y baksın

// === Yardımcılar ===
const V=(x=0,y=0,z=0)=>new THREE.Vector3(x,y,z);
const cm=v=>v*0.01;
const clear=g=>{ while(g.children.length){ const c=g.children.pop(); c.geometry?.dispose?.(); if(c.material){ (Array.isArray(c.material)?c.material:[c.material]).forEach(m=>m.dispose?.()); } } };
const addLabel=(txt,pos,color)=>{ const d=document.createElement('div'); d.className='label'; d.textContent=txt; if(color) d.style.color=color; const o=new CSS2DObject(d); o.position.copy(pos); S.add(o); GD.add(o); return o; };
const arrowBoth=(p1,p2,color=0xff4d4d,head=0.04,rad=0.01)=>{ const ln=new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1,p2]), new THREE.LineBasicMaterial({color,depthTest:!P.dimAlwaysOnTop,depthWrite:!P.dimAlwaysOnTop,transparent:P.dimAlwaysOnTop})); ln.renderOrder=P.dimAlwaysOnTop?999:0; const dir=V().subVectors(p2,p1).normalize(); const mk=(q,p)=>{ const c=new THREE.Mesh(new THREE.ConeGeometry(rad,head,12), new THREE.MeshBasicMaterial({color,depthTest:!P.dimAlwaysOnTop,depthWrite:!P.dimAlwaysOnTop,transparent:P.dimAlwaysOnTop})); c.quaternion.copy(q); c.position.copy(p); c.renderOrder=P.dimAlwaysOnTop?999:0; return c; }; const q2=new THREE.Quaternion().setFromUnitVectors(V(0,1,0),dir), q1=new THREE.Quaternion().setFromUnitVectors(V(0,1,0),dir.clone().negate()); GD.add(ln, mk(q2,p2), mk(q1,p1)); };
const dimLine=(p1,p2,offsetDir,label,color)=>{ const n=offsetDir.clone().normalize(), gap=cm(P.extGapCm); const targetOff=P.dimFixedOffset? cm(P.dimPlaneOffsetCm) : (gap+cm(P.extLenCm)); const s1=p1.clone().add(n.clone().multiplyScalar(gap)), e1=p1.clone().add(n.clone().multiplyScalar(targetOff)); const s2=p2.clone().add(n.clone().multiplyScalar(gap)), e2=p2.clone().add(n.clone().multiplyScalar(targetOff)); const mat=new THREE.LineBasicMaterial({color:new THREE.Color(color||0xff4d4d),depthTest:!P.dimAlwaysOnTop,depthWrite:!P.dimAlwaysOnTop,transparent:P.dimAlwaysOnTop}); const L1=new THREE.Line(new THREE.BufferGeometry().setFromPoints([s1,e1]),mat), L2=new THREE.Line(new THREE.BufferGeometry().setFromPoints([s2,e2]),mat); L1.renderOrder=L2.renderOrder=P.dimAlwaysOnTop?999:0; GD.add(L1,L2); const head=cm(P.arrowHeadCm), rad=cm(P.arrowRadiusCm), dir=V().subVectors(e2,e1).normalize(), off=cm(P.dimOffsetCm); const a1=e1.clone().add(dir.clone().multiplyScalar(off)), a2=e2.clone().add(dir.clone().multiplyScalar(-off)); arrowBoth(a1,a2,color,head,rad); const mid=a1.clone().add(a2).multiplyScalar(0.5).add(n.clone().multiplyScalar(cm(P.labelOffsetCm))); return addLabel(label, mid, color); };
const triA=(a,b,c)=>{ const ab=V().subVectors(b,a), ac=V().subVectors(c,a); return ab.cross(ac).length()*0.5; };
const flangeRect=(Wm,Hm,lip,th)=>{ const sh=new THREE.Shape([ new THREE.Vector2(-Wm/2-lip,-Hm/2-lip), new THREE.Vector2(Wm/2+lip,-Hm/2-lip), new THREE.Vector2(Wm/2+lip,Hm/2+lip), new THREE.Vector2(-Wm/2-lip,Hm/2+lip) ]); const hole=new THREE.Path([ new THREE.Vector2(-Wm/2,-Hm/2), new THREE.Vector2(Wm/2,-Hm/2), new THREE.Vector2(Wm/2,Hm/2), new THREE.Vector2(-Wm/2,Hm/2) ]); sh.holes.push(hole); const g=new THREE.ExtrudeGeometry(sh,{depth:th,bevelEnabled:false}); g.center(); const m=new THREE.Mesh(g, flangeMat); m.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), edgeMat)); return m; };
function rectCorners(hx,hy){ return [ new THREE.Vector3(-hx,-hy,0), new THREE.Vector3(hx,-hy,0), new THREE.Vector3(hx,hy,0), new THREE.Vector3(-hx,hy,0) ]; }

function ensureFacePorts(key,n){ const f=P.faces[key]; if(!f) return; if(!Array.isArray(f.ports)) f.ports=[]; while(f.ports.length<n) f.ports.push({diam:P.Phi}); if(f.ports.length>n) f.ports.length=n; f.count=n; }

// Yüz tanımları: n (normal), v (Ø ölçüsünün yönü ve dizilim ekseni), base merkez
function faceDefs(W1,H1,L,cx,cy){ return {
  right:{ n:V(1,0,0),  v:V(0,1,0), span:H1, base:V(cx(0.5)+W1/2, cy(0.5), L*0.5) },
  left: { n:V(-1,0,0), v:V(0,1,0), span:H1, base:V(cx(0.5)-W1/2, cy(0.5), L*0.5) },
  front:{ n:V(0,0,1),  v:V(1,0,0), span:W1, base:V(cx(0.5),     cy(0.5), L    ) },
  back: { n:V(0,0,-1), v:V(1,0,0), span:W1, base:V(cx(0.5),     cy(0.5), 0    ) },
  top:  { n:V(0,1,0),  v:V(1,0,0), span:W1, base:V(cx(0.5),     cy(0.5)+H1/2, L*0.5) },
  bottom:{ n:V(0,-1,0), v:V(1,0,0), span:W1, base:V(cx(0.5),    cy(0.5)-H1/2, L*0.5) }
}; }

function addPortsOnFace(key, fdef, diamList){ if(!diamList?.length) return; const n=fdef.n.clone().normalize(); const v=fdef.v.clone().normalize(); const u=new THREE.Vector3().crossVectors(v,n).normalize();
  const qCyl=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), n); // silindir ekseni Y → n
  const qRing=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), n); // halka/hole düzlemi Z → n
  const len=cm(P.spigotLenCm), eps=0.0005;
  const Dm=diamList.map(d=>cm(d)); const sumDm=Dm.reduce((a,b)=>a+b,0); const span=fdef.span;
  const g=Math.max(0,(span - sumDm)/(Dm.length+1)); if(span < sumDm){ addLabel(`⚠ ${key}: ΣØ > span`, fdef.base.clone().add(n.clone().multiplyScalar(0.05)), '#f66'); }
  let acc=0;
  for(let i=0;i<Dm.length;i++){
    const D=Dm[i], r=Math.max(D/2,1e-5);
    const off=-span/2 + g + r + acc; acc+=D+g;
    const center=fdef.base.clone().add(v.clone().multiplyScalar(off));
    const tube=new THREE.Mesh(new THREE.CylinderGeometry(r,r,len,48,1,true), metalMat); tube.quaternion.copy(qCyl); tube.position.copy(center.clone().add(n.clone().multiplyScalar(len/2)));
    const ring=new THREE.Mesh(new THREE.RingGeometry(Math.max(r-cm(P.t),1e-5), r, 48), metalMat); ring.quaternion.copy(qRing); ring.position.copy(center.clone().add(n.clone().multiplyScalar(eps)));
    const hole=new THREE.Mesh(new THREE.CircleGeometry(r*0.999,48), new THREE.MeshBasicMaterial({color:0x0b0e12,side:THREE.DoubleSide})); hole.quaternion.copy(qRing); hole.position.copy(center.clone().add(n.clone().multiplyScalar(eps*0.5)));
    GF.add(tube,ring,hole);
    // Ø ölçüsü için iki uç (v yönünde) + offset yönü (n)
    const pA=center.clone().add(v.clone().multiplyScalar(-r));
    const pB=center.clone().add(v.clone().multiplyScalar( r));
    dimsToDraw.push({pA,pB,off:n.clone(),text:`Ø = ${(Dm[i]*100).toFixed(1)} cm`});
  }
}

function frameFit(o){ const box=new THREE.Box3().setFromObject(o); const size=box.getSize(new THREE.Vector3()); const ctr=box.getCenter(new THREE.Vector3()); const md=Math.max(size.x,size.y,size.z); const dist=md/(2*Math.tan(THREE.MathUtils.degToRad(Cam.fov/2)))*1.1; const dir=new THREE.Vector3(1,0.8,1).normalize(); Cam.position.copy(ctr.clone().add(dir.multiplyScalar(dist))); Cam.near=dist/100; Cam.far=dist*100; Cam.updateProjectionMatrix(); Ctrl.target.copy(ctr); Ctrl.update(); lastCtr.copy(ctr); lastDist=dist; }

let dimsToDraw=[];

// === İnşa ===
function build(){
  try{
    clear(G); clear(GF); clear(GD); document.querySelectorAll('.label').forEach(e=>e.remove());
    dimsToDraw=[];
    const W1=cm(P.W1), H1=cm(P.H1), L=cm(P.L), t=cm(P.t), lip=cm(P.flangeLip), fth=cm(P.flangeThick);
    const n=V(1,0,0), b=V(0,1,0), tz=V(0,0,1);
    const N=4;
    const rectO=rectCorners(W1/2, H1/2);
    const rectI=rectCorners(Math.max(W1/2-t,1e-5), Math.max(H1/2-t,1e-5));
    const left0=-W1/2, right0=W1/2, bottom0=-H1/2, top0=H1/2;
    const cx=(u)=> 0; // merkezde tut
    const cy=(u)=> 0;

    // Gövde
    const vs=[], idx=[]; const Rout=[], Rin=[];
    for(let i=0;i<=P.steps;i++){
      const u=i/P.steps; const O=[], I=[];
      for(let k=0;k<N;k++){
        const po=rectO[k].clone(); po.x+=cx(u); po.y+=cy(u); po.z=u*L;
        const pi=rectI[k].clone(); pi.x+=cx(u); pi.y+=cy(u); pi.z=u*L;
        O.push(po); I.push(pi);
      }
      Rout.push(O); Rin.push(I);
    }
    const push=r=>{for(const v of r){vs.push(v.x,v.y,v.z)}};
    for(let i=0;i<=P.steps;i++) push(Rout[i]); const innerBase=vs.length/3; for(let i=0;i<=P.steps;i++) push(Rin[i]);
    const quad=(a,b,c,d)=>{idx.push(a,b,c,a,c,d)};
    for(let i=0;i<P.steps;i++){ const b0=i*N, b1=(i+1)*N; for(let k=0;k<N;k++){ const a=b0+k, bI=b0+(k+1)%N, c=b1+(k+1)%N, d=b1+k; quad(a,bI,c,d); } }
    for(let i=0;i<P.steps;i++){ const b0=innerBase+i*N, b1=innerBase+(i+1)*N; for(let k=0;k<N;k++){ const a=b0+k, bI=b0+(k+1)%N, c=b1+(k+1)%N, d=b1+k; quad(d,c,bI,a); } }
    const geo=new THREE.BufferGeometry(); geo.setAttribute('position',new THREE.Float32BufferAttribute(vs,3)); geo.setIndex(idx); geo.computeVertexNormals();
    const msh=new THREE.Mesh(geo, metalMat); G.add(msh); if(P.showEdges) G.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo,1),edgeMat));
    const back=new THREE.Mesh(new THREE.PlaneGeometry(W1,H1), metalMat); back.position.set(cx(0),cy(0),0); G.add(back); if(P.showEdges) G.add(new THREE.LineSegments(new THREE.EdgesGeometry(back.geometry), edgeMat));

    if(P.showFlange){ const p1=V(cx(1),cy(1),L); const F=flangeRect(W1,H1,lip,fth); const M=new THREE.Matrix4().makeBasis(n.clone(),b.clone(),tz.clone()); const Q=new THREE.Quaternion().setFromRotationMatrix(M); F.position.copy(p1.clone().add(tz.clone().multiplyScalar(fth*0.5))); F.quaternion.copy(Q); GF.add(F); }

    // === Manşonlar (çoklu yüz) ===
    const defs=faceDefs(W1,H1,L,cx,cy);
    // Kullanıcı talebine göre eşleme:
    // a) ALT ↔ ÖN  (dashboard'ta Ön Yüz = ALT (bottom))
    // b) ÜST ↔ ARKA (dashboard'ta Üst Yüz = ARKA (back), Arka Yüz = ÜST (top))
    const mapFace = { right:'right', left:'left', front:'bottom', back:'top', top:'back' };
    for(const k of ['right','left','front','back','top']){
      const f=P.faces[k]; if(!f) continue; ensureFacePorts(k, f.count||0);
      const target = defs[ mapFace[k] ];
      addPortsOnFace(k, target, f.ports.map(p=>Number(p.diam)||P.Phi));
    }

    // Alan ve HUD (kısa)
    let Aout=0; for(let i=0;i<P.steps;i++){ const r0=Rout[i], r1=Rout[i+1]; for(let k=0;k<N;k++){ const v00=r0[k], v01=r0[(k+1)%N], v11=r1[(k+1)%N], v10=r1[k]; Aout+=triA(v00,v01,v11)+triA(v00,v11,v10); } } Aout+=W1*H1;
    const sheet=Aout*(P.kFactor??1); const waste=sheet*(1+((P.wastePercent||0)/100));

    // Ölçülendirme (W1/H1/L + Ø)
    if(P.showDims){
      const nX=V(1,0,0), nY=V(0,1,0), nZ=V(0,0,1); const p1=V(0,0,L);
      const xL=nX.clone().multiplyScalar(-W1/2), xR=nX.clone().multiplyScalar(W1/2), yT=nY.clone().multiplyScalar(H1/2), yB=nY.clone().multiplyScalar(-H1/2);
      dimLine(p1.clone().add(xL).add(yT), p1.clone().add(xR).add(yT), nY, `W1 = ${P.W1.toFixed(1)} cm`, P.colorW1);
      dimLine(p1.clone().add(xR).add(yB), p1.clone().add(xR).add(yT), nX, `H1 = ${P.H1.toFixed(1)} cm`, P.colorH1);
      dimLine(V(-W1/2,-H1/2,0), V(-W1/2,-H1/2,L), nX.clone().negate(), `L = ${P.L.toFixed(1)} cm`, P.colorL);
      // Ø ölçüleri (her manşon, doğru offset yönüyle)
      dimsToDraw.forEach(d=> dimLine(d.pA,d.pB,d.off, d.text, P.colorPhi));
    }

    // Yüz etiketleri (ALT↔ÖN ve ÜST↔ARKA takası uygulanmış)
    if(P.showSideLabels){
      // SAĞ/SOL aynı
      addLabel('SAĞ',  V(W1*0.5+0.02, 0, L*0.5), '#ff6');
      addLabel('SOL',  V(-W1*0.5-0.02, 0, L*0.5), '#ff6');
      // Takas edilenler
      addLabel('ALT',  V(0, 0, L-0.02), '#ff6');       // Ön yüz (Z+) yerine ALT yazıyor
      addLabel('ÖN',   V(0, -H1*0.5-0.02, L*0.5), '#ff6'); // Alt (Y-) yerine ÖN yazıyor
      addLabel('ÜST',  V(0, 0, 0.02), '#ff6');         // Arka (Z-) yerine ÜST yazıyor
      addLabel('ARKA', V(0,  H1*0.5+0.02, L*0.5), '#ff6'); // Üst (Y+) yerine ARKA yazıyor
    }

    // Kadraj & HUD
    // Kadraj & HUD — ölçü değişiminde görüşü koru
const preserve = P.keepViewOnEdit && didInitialFrame;
let camState;
if (preserve){ camState = { pos: Cam.position.clone(), quat: Cam.quaternion.clone(), tgt: Ctrl.target.clone() }; }
if (!preserve){ frameFit(G); didInitialFrame = true; }
else { Cam.position.copy(camState.pos); Cam.quaternion.copy(camState.quat); Cam.updateProjectionMatrix(); Ctrl.target.copy(camState.tgt); Ctrl.update(); lastCtr.copy(Ctrl.target); lastDist = Cam.position.distanceTo(Ctrl.target); }
    areaEl.textContent = `Dış: ${Aout.toFixed(3)} m² | k=${(P.kFactor??1).toFixed(2)} ⇒ ${sheet.toFixed(3)} m² | +%${(P.wastePercent||0).toFixed(1)} atık ⇒ ${waste.toFixed(3)} m²`;

  }catch(err){ console.error('[BUILD ERROR]',err); areaEl.textContent='Hata: '+err.message; }
}

// === Başlat ===
build();

// === GUI ===
const gui=new GUI({title:'Parametreler'});
const add=(f,o,k,min,max,step,name)=>f.add(o,k,min,max,step).name(name).onChange(build);
const F1=gui.addFolder('Ölçüler (cm)');
[ ['W1',1,400,0.1,'W1 (genişlik) cm'], ['H1',1,400,0.1,'H1 (yükseklik) cm'], ['L',1,1000,0.1,'L (derinlik) cm'], ['Phi',1,400,0.1,'Ø varsayılan (cm)'], ['spigotLenCm',1,100,0.1,'Manşon Uzunluğu (cm)'], ['t',0.02,1,0.01,'Sac Kalınlığı t'], ['steps',8,400,1,'Boyuna Segment (steps)'] ].forEach(p=>add(F1,P,p[0],p[1],p[2],p[3],p[4]));

function rebuildFaceInputs(key, folder){ if(folder.__portsFolder){ folder.__portsFolder.destroy(); } const f=P.faces[key]; ensureFacePorts(key, f.count||0); const sub=folder.addFolder('Çaplar'); folder.__portsFolder=sub; f.ports.forEach((obj,i)=>{ sub.add(obj,'diam',1,400,0.1).name(`${i+1}. Ø (cm)`).onChange(build); }); sub.open(); }
function faceFolder(name,key){ const fldr=gui.addFolder(name); fldr.add(P.faces[key],'count',0,20,1).name('Adet').onChange(v=>{ ensureFacePorts(key,v); rebuildFaceInputs(key,fldr); build(); }); rebuildFaceInputs(key,fldr); return fldr; }

let FRight=faceFolder('Sağ Yüz','right');
let FLeft =faceFolder('Sol Yüz','left');
// Etiket eşleştirmesi kullanıcı isteğine göre değiştirildi: ÜST↔ARKA, ALT↔ÖN
let FFront=faceFolder('Ön Yüz','front'); // Ön = Z+
let FBack =faceFolder('Arka Yüz','back'); // Arka = Z-
let FTop  =faceFolder('Üst Yüz','top');   // Üst = Y+

const F2=gui.addFolder('Görünüm / Flanş');
['showEdges','showDims','showFlange','showSideLabels'].forEach(k=>F2.add(P,k).name({showEdges:'Kenar Çizgileri',showDims:'Ölçülendirme',showFlange:'Flanşı Göster',showSideLabels:'Yüz Etiketleri'}[k]).onChange(build));
F2.add(P,'keepViewOnEdit').name('Ölçü değişince görüşü koru');
add(F2,P,'flangeLip',0.5,8,0.1,'Flanş Payı (lip) cm'); add(F2,P,'flangeThick',0.2,2,0.05,'Flanş Kalınlığı cm');
F2.add(P,'metalRough',0,1,0.01).name('Roughness').onChange(()=>{ metalMat.roughness=P.metalRough; R.render(S,Cam); });
F2.add(P,'metalness',0,1,0.01).name('Metalness').onChange(()=>{ metalMat.metalness=P.metalness; R.render(S,Cam); });
F2.add(P,'showAxis').name('Eksenleri Göster').onChange(v=>Ax.visible=v);
F2.add(P,'showGrid').name('Grid Göster').onChange(v=>Grid.visible=v);
F2.add(P,'dimAlwaysOnTop').name('Ölçüler hep üstte').onChange(build);
F2.add(P,'dimFixedOffset').name('Flanştan sabit uzaklık').onChange(build);
[ ['dimOffsetCm',0.5,5,0.1,'Ok Ucu Kısalt (cm)'], ['arrowHeadCm',1,8,0.1,'Ok Boyu (cm)'], ['arrowRadiusCm',0.5,3,0.1,'Ok Kalınlığı (cm)'], ['extLenCm',2,40,0.5,'Uzatma Uzunluğu (cm)'], ['extGapCm',0.2,5,0.1,'Parça Boşluğu (cm)'], ['dimPlaneOffsetCm',1,100,0.5,'Flanştan Mesafe (cm)'], ['labelOffsetCm',0,5,0.1,'Etiket Ofset (cm)'] ].forEach(p=>add(F2,P,p[0],p[1],p[2],p[3],p[4]));

const F3=gui.addFolder('Renkler');
[ ['colorW1','W1 Rengi'], ['colorH1','H1 Rengi'], ['colorL','L Rengi'], ['colorPhi','Ø Rengi'] ].forEach(p=>F3.addColor(P,p[0]).name(p[1]).onChange(build));

const FA=gui.addFolder('Alan Hesabı');
FA.add(P,'areaIncludeFlange').name('Flanşı dahil et').onChange(build);
FA.add(P,'wastePercent',0,100,1).name('% Atık/Pay').onChange(build);
FA.add(P,'kFactor',0,2,0.01).name('Düzeltme Katsayısı k').onChange(build);

// === Döngü ===
addEventListener('resize',()=>{ Cam.aspect=innerWidth/innerHeight; Cam.updateProjectionMatrix(); R.setSize(innerWidth,innerHeight); LBL.setSize(innerWidth,innerHeight); });
(function anim(){ requestAnimationFrame(anim); Ctrl.update(); R.render(S,Cam); LBL.render(S,Cam); })();
</script>
<script src="js/child-bridge.js"></script>
</body></html>
