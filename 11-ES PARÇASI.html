<!DOCTYPE html><html lang="tr"><head><meta charset="utf-8"/>
<title>Three.js – Offset (ES) Parçası • W1/H1 → W2/H2, L, ES</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#0b0e12}
  #hud{position:absolute;top:10px;left:10px;z-index:10;color:#e6edf3;font:13px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .label{color:inherit;font-weight:700;background:rgba(18,24,34,.9);padding:4px 8px;border:1px solid #39414f;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.35);text-shadow:none}
  #viewbar{position:absolute;left:50%;transform:translateX(-50%);bottom:10px;display:flex;gap:6px;z-index:11}
  #viewbar .vbtn{background:#1b2230;color:#e6edf3;border:1px solid #39414f;border-radius:6px;padding:4px 6px;font:12px system-ui;cursor:pointer;opacity:.9;display:flex;align-items:center;gap:2px}
  #viewbar .vbtn .vicon{width:32px;height:32px;display:inline-block}
  #viewbar .vbtn:hover{opacity:1}
</style>
<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/"}}</script>
</head><body>
<div style="position:absolute;top:10px;left:10px;z-index:100;background:rgba(18,24,34,0.9);padding:8px 12px;border-radius:8px;display:flex;align-items:center;gap:10px;border:1px solid #39414f;">
  <a href="/" style="display:flex;align-items:center;">
    <img src="/logo23dductorder.png" alt="3D Duct Order Logo" style="height:30px;width:auto;">
  </a>
  <span style="color:#e6edf3;font-weight:600;font-size:14px;">ES Parçası</span>
</div>
<div id="hud">Sol tık: döndür • Sağ tık: kaydır • Tekerlek: zoom</div>
<canvas id="c"></canvas>
<div id="viewbar">
  <button class="vbtn" data-v="Right">Right</button>
  <button class="vbtn" data-v="Left">Left</button>
  <button class="vbtn" data-v="Front">Front</button>
  <button class="vbtn" data-v="Back">Back</button>
  <button class="vbtn" data-v="Top">Top</button>
  <button class="vbtn" data-v="SW Iso">SW Iso</button>
  <button class="vbtn" data-v="NE Iso">NE Iso</button>
</div>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

// === Temel kurulum ===
const C=document.getElementById('c');
const R=new THREE.WebGLRenderer({canvas:C,antialias:true,alpha:true});
R.setSize(innerWidth,innerHeight); R.setPixelRatio(Math.min(2,devicePixelRatio));
const S=new THREE.Scene();
const Cam=new THREE.PerspectiveCamera(45,innerWidth/innerHeight,0.01,1e4); Cam.position.set(3.2,1.9,3.2); S.add(Cam);
S.add(new THREE.HemisphereLight(0xffffff,0x101018,0.9)); const DL=new THREE.DirectionalLight(0xffffff,0.7); DL.position.set(3,5,4); S.add(DL);
const Ctrl=new OrbitControls(Cam,R.domElement); Ctrl.enableDamping=true;
const Grid=new THREE.GridHelper(10,20,0x2a2e35,0x1a1d23); S.add(Grid);
const Ax=new THREE.AxesHelper(1); S.add(Ax);
const LBL=new CSS2DRenderer(); LBL.setSize(innerWidth,innerHeight); Object.assign(LBL.domElement.style,{position:'absolute',top:'0',pointerEvents:'none'}); document.body.appendChild(LBL.domElement);
const hud=document.getElementById('hud'); const areaEl=document.createElement('div'); areaEl.style.marginTop='6px'; hud.appendChild(areaEl);
const viewbar=document.getElementById('viewbar');
let lastCtr=new THREE.Vector3(); let lastDist=3; let didInitialFrame=false;
const views={ 'Right':new THREE.Vector3(1,0,0),'Left':new THREE.Vector3(-1,0,0),'Front':new THREE.Vector3(0,0,1),'Back':new THREE.Vector3(0,0,-1),'Top':new THREE.Vector3(0,1,0),'SW Iso':new THREE.Vector3(-1,1,-1),'NE Iso':new THREE.Vector3(1,1,1)};
function setView(dir){ const v=dir.clone().normalize().multiplyScalar(lastDist); Cam.position.copy(lastCtr.clone().add(v)); Cam.near=lastDist/100; Cam.far=lastDist*100; Cam.updateProjectionMatrix(); Ctrl.target.copy(lastCtr); Ctrl.update(); }
viewbar?.querySelectorAll('.vbtn').forEach(b=>b.addEventListener('click',()=>{ const v=views[b.dataset.v]; if(v) setView(v); }));

// --- Küçük görünüm ikonları (inline SVG) ---
function cubeSVG(highlight){
  const stroke='#9aa7b1', face='#263040', acc='#4cc3ff';
  const top=`<polygon points="6,10 12,6 18,10 12,14" fill="${highlight==='top'?acc:face}" stroke="${stroke}" stroke-width="1"/>`;
  const left=`<polygon points="6,10 6,18 12,22 12,14" fill="${highlight==='left'?acc:face}" stroke="${stroke}" stroke-width="1"/>`;
  const right=`<polygon points="12,14 12,22 18,18 18,10" fill="${highlight==='right'?acc:face}" stroke="${stroke}" stroke-width="1"/>`;
  return `<svg class="vicon" viewBox="0 0 24 24" aria-hidden="true">${top}${left}${right}</svg>`;
}
function faceSVG(){ const stroke='#9aa7b1', acc='#4cc3ff'; return `<svg class="vicon" viewBox="0 0 24 24" aria-hidden="true"><rect x="6" y="6" width="12" height="12" rx="2" ry="2" fill="${acc}" stroke="${stroke}" stroke-width="1"/></svg>`; }
function backSVG(){ const stroke='#9aa7b1', acc='#4cc3ff', face='#263040'; return `<svg class="vicon" viewBox="0 0 24 24" aria-hidden="true"><rect x="5" y="5" width="12" height="12" rx="2" ry="2" fill="${face}" stroke="${stroke}" stroke-width="1"/><rect x="7" y="7" width="12" height="12" rx="2" ry="2" fill="${acc}" stroke="${stroke}" stroke-width="1"/></svg>`; }
function isoSVG(){ return cubeSVG(null); }
function iconSVG(name){ switch(name){
  case 'Top': return cubeSVG('top');
  case 'Left': return cubeSVG('left');
  case 'Right': return cubeSVG('right');
  case 'Front': return faceSVG();
  case 'Back': return backSVG();
  case 'SW Iso': return isoSVG();
  case 'NE Iso': return isoSVG();
  default: return isoSVG();
}}
viewbar?.querySelectorAll('.vbtn').forEach(btn=>{ const label=btn.textContent; const svg=iconSVG(btn.dataset.v||label); btn.innerHTML = svg + `<span>${label}</span>`; });

// === Parametreler ===
const P={ W1:100, H1:80, W2:100, H2:80, L:120, ES:60, ESmarginCm:5, t:0.12, steps:64,
  showEdges:true, showDims:true, showFlange:true,
  flangeLip:3, flangeThick:0.6,
  metalRough:0.35, metalness:0.85,
  showAxis:false, showGrid:true, keepViewOnEdit:true,
  dimOffsetCm:1.5, arrowHeadCm:4, arrowRadiusCm:1.2,
  extLenCm:15, extGapCm:1, dimPlaneOffsetCm:20, labelOffsetCm:0.5,
  dimAlwaysOnTop:true, dimFixedOffset:true,
  colorW1:'#207aff', colorH1:'#ff2d2d', colorW2:'#8e24aa', colorH2:'#ff9800', colorL:'#00bcd4', colorES:'#207aff',
  areaIncludeFlange:false, wastePercent:25, kFactor:1
};

const metalMat=new THREE.MeshPhysicalMaterial({color:0xbfc7d2,roughness:P.metalRough,metalness:P.metalness,clearcoat:0.5,clearcoatRoughness:0.25,side:THREE.DoubleSide});
const flangeMat=new THREE.MeshPhysicalMaterial({color:0x9aa3ad,roughness:0.6,metalness:0.9});
const edgeMat=new THREE.LineBasicMaterial({color:0x3a3f46});
const G=new THREE.Group(), GF=new THREE.Group(), GD=new THREE.Group(); S.add(G,GF,GD);
const GL=new THREE.Group(); S.add(GL);

// === Yardımcılar ===
const V=(x=0,y=0,z=0)=>new THREE.Vector3(x,y,z);
const cm=v=>v*0.01;
const clear=g=>{ while(g.children.length){ const c=g.children.pop(); c.geometry?.dispose?.(); if(c.material){ (Array.isArray(c.material)?c.material:[c.material]).forEach(m=>m.dispose?.()); } } };
const addLabel=(txt,pos,color)=>{ const d=document.createElement('div'); d.className='label'; d.textContent=txt; if(color) d.style.color=color; const o=new CSS2DObject(d); o.position.copy(pos); S.add(o); GD.add(o); return o; };
const addLabelRoot=(txt,pos,color)=>{ const d=document.createElement('div'); d.className='label'; d.textContent=txt; if(color) d.style.color=color; const o=new CSS2DObject(d); o.position.copy(pos); GL.add(o); return o; };
const arrowBoth=(p1,p2,color=0x207aff,head=0.04,rad=0.01)=>{ const ln=new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1,p2]), new THREE.LineBasicMaterial({color,depthTest:!P.dimAlwaysOnTop,depthWrite:!P.dimAlwaysOnTop,transparent:P.dimAlwaysOnTop})); ln.renderOrder=P.dimAlwaysOnTop?999:0; const dir=V().subVectors(p2,p1).normalize(); const mk=(q,p)=>{ const c=new THREE.Mesh(new THREE.ConeGeometry(rad,head,12), new THREE.MeshBasicMaterial({color,depthTest:!P.dimAlwaysOnTop,depthWrite:!P.dimAlwaysOnTop,transparent:P.dimAlwaysOnTop})); c.quaternion.copy(q); c.position.copy(p); c.renderOrder=P.dimAlwaysOnTop?999:0; return c; }; const q2=new THREE.Quaternion().setFromUnitVectors(V(0,1,0),dir), q1=new THREE.Quaternion().setFromUnitVectors(V(0,1,0),dir.clone().negate()); GD.add(ln, mk(q2,p2), mk(q1,p1)); };
const dimLine=(p1,p2,offsetDir,label,color)=>{ const n=offsetDir.clone().normalize(); const gap=cm(P.extGapCm); const targetOff=P.dimFixedOffset? cm(P.dimPlaneOffsetCm) : (gap+cm(P.extLenCm)); const s1=p1.clone().add(n.clone().multiplyScalar(gap)), e1=p1.clone().add(n.clone().multiplyScalar(targetOff)); const s2=p2.clone().add(n.clone().multiplyScalar(gap)), e2=p2.clone().add(n.clone().multiplyScalar(targetOff)); const mat=new THREE.LineBasicMaterial({color:new THREE.Color(color||0x207aff),depthTest:!P.dimAlwaysOnTop,depthWrite:!P.dimAlwaysOnTop,transparent:P.dimAlwaysOnTop}); const L1=new THREE.Line(new THREE.BufferGeometry().setFromPoints([s1,e1]),mat), L2=new THREE.Line(new THREE.BufferGeometry().setFromPoints([s2,e2]),mat); L1.renderOrder=L2.renderOrder=P.dimAlwaysOnTop?999:0; GD.add(L1,L2); const head=cm(P.arrowHeadCm), rad=cm(P.arrowRadiusCm), dir=V().subVectors(e2,e1).normalize(), off=cm(P.dimOffsetCm); const a1=e1.clone().add(dir.clone().multiplyScalar(off)); const a2=e2.clone().add(dir.clone().multiplyScalar(-off)); arrowBoth(a1,a2,color,head,rad); const mid=a1.clone().add(a2).multiplyScalar(0.5).add(n.clone().multiplyScalar(cm(P.labelOffsetCm))); return addLabel(label, mid, color); };
const triA=(a,b,c)=>{ const ab=V().subVectors(b,a), ac=V().subVectors(c,a); return ab.cross(ac).length()*0.5; };
const flangeRect=(Wm,Hm,lip,th)=>{ const sh=new THREE.Shape([ new THREE.Vector2(-Wm/2-lip,-Hm/2-lip), new THREE.Vector2(Wm/2+lip,-Hm/2-lip), new THREE.Vector2(Wm/2+lip,Hm/2+lip), new THREE.Vector2(-Wm/2-lip,Hm/2+lip) ]); const hole=new THREE.Path([ new THREE.Vector2(-Wm/2,-Hm/2), new THREE.Vector2(Wm/2,-Hm/2), new THREE.Vector2(Wm/2,Hm/2), new THREE.Vector2(-Wm/2,Hm/2) ]); sh.holes.push(hole); const g=new THREE.ExtrudeGeometry(sh,{depth:th,bevelEnabled:false}); g.center(); const m=new THREE.Mesh(g, flangeMat); m.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), edgeMat)); return m; };

function frameFit(o){ const box=new THREE.Box3().setFromObject(o); const size=box.getSize(new THREE.Vector3()); const ctr=box.getCenter(new THREE.Vector3()); const md=Math.max(size.x,size.y,size.z); const dist=md/(2*Math.tan(THREE.MathUtils.degToRad(Cam.fov/2)))*1.1; const dir=new THREE.Vector3(1,0.8,1).normalize(); Cam.position.copy(ctr.clone().add(dir.multiplyScalar(dist))); Cam.near=dist/100; Cam.far=dist*100; Cam.updateProjectionMatrix(); Ctrl.target.copy(ctr); Ctrl.update(); lastCtr.copy(ctr); lastDist=dist; }

// === İnşa ===
function build(){
  try{
    // temizle
    [G,GF,GD].forEach(clear); clear(GL); document.querySelectorAll('.label').forEach(e=>e.remove());

    const W1=cm(P.W1), H1=cm(P.H1), W2=cm(P.W2), H2=cm(P.H2), L=cm(P.L), ES=cm(P.ES), t=cm(P.t), lip=cm(P.flangeLip), fth=cm(P.flangeThick);

    // Parametrik geçiş: W/H lineer, merkez X ofseti 0→ES, Z: 0→L
    const steps=Math.max(8,Math.floor(P.steps));
    const vs=[], idx=[]; const N=4; const Rout=[], Rin=[];
    const lerp=(a,b,u)=>a+(b-a)*u;
    for(let i=0;i<=steps;i++){
      const u=i/steps; const w=lerp(W1,W2,u), h=lerp(H1,H2,u); // ES ofseti: flanşlardan marj bırakarak, yumuşak geçiş
      const m=Math.min(cm(P.ESmarginCm||5), Math.max(0, L*0.5-1e-6));
      let s = (L<=2*m)? u : THREE.MathUtils.clamp(((u*L) - m)/(L - 2*m), 0, 1);
      s = s*s*(3 - 2*s); // smoothstep
      const cx=ES * s; const z=u*L;
      const wo=Math.max(w/2,1e-6), ho=Math.max(h/2,1e-6);
      const wi=Math.max(wo-t,1e-6), hi=Math.max(ho-t,1e-6);
      const O=[ new THREE.Vector3(cx-wo,-ho,z), new THREE.Vector3(cx+wo,-ho,z), new THREE.Vector3(cx+wo,ho,z), new THREE.Vector3(cx-wo,ho,z) ];
      const I=[ new THREE.Vector3(cx-wi,-hi,z), new THREE.Vector3(cx+wi,-hi,z), new THREE.Vector3(cx+wi,hi,z), new THREE.Vector3(cx-wi,hi,z) ];
      Rout.push(O); Rin.push(I);
    }
    const push=r=>{for(const v of r){vs.push(v.x,v.y,v.z)}};
    for(let i=0;i<=steps;i++) push(Rout[i]); const innerBase=vs.length/3; for(let i=0;i<=steps;i++) push(Rin[i]);
    const quad=(a,b,c,d)=>{idx.push(a,b,c,a,c,d)};
    for(let i=0;i<steps;i++){ const b0=i*N, b1=(i+1)*N; for(let k=0;k<N;k++){ const a=b0+k, bI=b0+(k+1)%N, c=b1+(k+1)%N, d=b1+k; quad(a,bI,c,d); } }
    for(let i=0;i<steps;i++){ const b0=innerBase+i*N, b1=innerBase+(i+1)*N; for(let k=0;k<N;k++){ const a=b0+k, bI=b0+(k+1)%N, c=b1+(k+1)%N, d=b1+k; quad(d,c,bI,a); } }
    const geo=new THREE.BufferGeometry(); geo.setAttribute('position',new THREE.Float32BufferAttribute(vs,3)); geo.setIndex(idx); geo.computeVertexNormals();
    const msh=new THREE.Mesh(geo, metalMat); G.add(msh); if(P.showEdges) G.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo,1),edgeMat));

    // Flanşlar: z=0 (x=0, W1xH1) ve z=L (x=ES, W2xH2)
    if(P.showFlange){
      const F0=flangeRect(W1,H1,lip,fth); F0.position.set(0,0,-fth*0.5); GF.add(F0);
      const F1=flangeRect(W2,H2,lip,fth); F1.position.set(ES,0,L+fth*0.5); GF.add(F1);
    }

    // Alan (opsiyonel)
    let Aout=0; for(let i=0;i<steps;i++){ const r0=Rout[i], r1=Rout[i+1]; for(let k=0;k<4;k++){ const v00=r0[k], v01=r0[(k+1)%4], v11=r1[(k+1)%4], v10=r1[k]; Aout+=triA(v00,v01,v11)+triA(v00,v11,v10); } } // dış kabuk
    const sheet=Aout*(P.kFactor??1); const waste=sheet*(1+((P.wastePercent||0)/100));

    // Ölçülendirme: W1/H1 (z=0), W2/H2 (z=L, x=ES), L (merkez hattı), ES (x ofseti)
    if(P.showDims){
      const yTop = Math.max(H1, H2) / 2;
      // W1 alt kenar (−Y ofset)
      dimLine(new THREE.Vector3(-W1/2,-H1/2,0), new THREE.Vector3(W1/2,-H1/2,0), new THREE.Vector3(0,-1,0), `W1 = ${P.W1.toFixed(1)} cm`, P.colorW1);
      // H1 sol kenar (−X ofset)
      dimLine(new THREE.Vector3(-W1/2,-H1/2,0), new THREE.Vector3(-W1/2,H1/2,0), new THREE.Vector3(-1,0,0), `H1 = ${P.H1.toFixed(1)} cm`, P.colorH1);

      // W2 üst kenar (+Y ofset) @ z=L, x=ES
      dimLine(new THREE.Vector3(ES-W2/2, H2/2, L), new THREE.Vector3(ES+W2/2, H2/2, L), new THREE.Vector3(0,1,0), `W2 = ${P.W2.toFixed(1)} cm`, P.colorW2);
      // H2 sol kenar (−X ofset) @ z=L, x=ES
      dimLine(new THREE.Vector3(ES-W2/2,-H2/2,L), new THREE.Vector3(ES-W2/2,H2/2,L), new THREE.Vector3(-1,0,0), `H2 = ${P.H2.toFixed(1)} cm`, P.colorH2);

      // L: Z boyunca (X=ES sabit), üst seviyede (Y=yTop), +Y ofset
      dimLine(new THREE.Vector3(ES, yTop, 0), new THREE.Vector3(ES, yTop, L), new THREE.Vector3(0,1,0), `L = ${P.L.toFixed(1)} cm`, P.colorL);
      // ES: ön yüzde (Z=0), üst seviyede (Y=H1/2), +Y ofset
      dimLine(new THREE.Vector3(0, H1/2, 0), new THREE.Vector3(ES, H1/2, 0), new THREE.Vector3(0,1,0), `ES = ${P.ES.toFixed(1)} cm`, P.colorES);
    }

    // Dünya eksen etiketleri (+X,+Y,+Z)
    const axisLen=1.2; Ax.scale.set(axisLen,axisLen,axisLen);
    addLabelRoot('+X', new THREE.Vector3(axisLen,0,0), '#ff6b6b');
    addLabelRoot('+Y', new THREE.Vector3(0,axisLen,0), '#5cff5c');
    addLabelRoot('+Z', new THREE.Vector3(0,0,axisLen), '#5cb6ff');

    // Kadraj & HUD (görüşü koru)
    const preserve = P.keepViewOnEdit && didInitialFrame; let camState;
    if (preserve){ camState = { pos: Cam.position.clone(), quat: Cam.quaternion.clone(), tgt: Ctrl.target.clone() }; }
    if (!preserve){ frameFit(G); didInitialFrame = true; }
    else { Cam.position.copy(camState.pos); Cam.quaternion.copy(camState.quat); Cam.updateProjectionMatrix(); Ctrl.target.copy(camState.tgt); Ctrl.update(); lastCtr.copy(Ctrl.target); lastDist = Cam.position.distanceTo(Ctrl.target); }

    areaEl.textContent = `Dış: ${Aout.toFixed(3)} m² | k=${(P.kFactor??1).toFixed(2)} ⇒ ${sheet.toFixed(3)} m² | +%${(P.wastePercent||0).toFixed(1)} atık ⇒ ${waste.toFixed(3)} m²`;

  }catch(err){ console.error('[BUILD ERROR]',err); areaEl.textContent='Hata: '+err.message; }
}

// === Başlat ===
build();

// === GUI ===
const gui=new GUI({title:'Parametreler'});
const add=(f,o,k,min,max,step,name)=>f.add(o,k,min,max,step).name(name).onChange(build);
const F1=gui.addFolder('Ölçüler (cm)');
[ ['W1',1,400,0.1,'W1 (ön) cm'], ['H1',1,400,0.1,'H1 (ön) cm'], ['W2',1,400,0.1,'W2 (arka) cm'], ['H2',1,400,0.1,'H2 (arka) cm'], ['L',1,1000,0.1,'L (merkez hattı) cm'], ['ES',0,1000,0.1,'ES (X ofset) cm'], ['ESmarginCm',0,100,0.1,'ES Marjı (baş/son) cm'], ['t',0.02,1,0.01,'Sac Kalınlığı t'], ['steps',8,200,1,'Boyuna Segment (steps)'] ].forEach(p=>add(F1,P,p[0],p[1],p[2],p[3],p[4]));

const F2=gui.addFolder('Görünüm / Flanş');
['showEdges','showDims','showFlange'].forEach(k=>F2.add(P,k).name({showEdges:'Kenar Çizgileri',showDims:'Ölçülendirme',showFlange:'Çift Flanş'}[k]).onChange(build));
F2.add(P,'keepViewOnEdit').name('Ölçü değişince görüşü koru');
add(F2,P,'flangeLip',0.5,8,0.1,'Flanş Payı (lip) cm'); add(F2,P,'flangeThick',0.2,2,0.05,'Flanş Kalınlığı cm');
F2.add(P,'metalRough',0,1,0.01).name('Roughness').onChange(()=>{ metalMat.roughness=P.metalRough; R.render(S,Cam); });
F2.add(P,'metalness',0,1,0.01).name('Metalness').onChange(()=>{ metalMat.metalness=P.metalness; R.render(S,Cam); });
F2.add(P,'showAxis').name('Eksenleri Göster').onChange(v=>Ax.visible=v);
F2.add(P,'showGrid').name('Grid Göster').onChange(v=>Grid.visible=v);
F2.add(P,'dimAlwaysOnTop').name('Ölçüler hep üstte').onChange(build);
F2.add(P,'dimFixedOffset').name('Flanştan sabit uzaklık').onChange(build);
[ ['dimOffsetCm',0.5,5,0.1,'Ok Ucu Kısalt (cm)'], ['arrowHeadCm',1,8,0.1,'Ok Boyu (cm)'], ['arrowRadiusCm',0.5,3,0.1,'Ok Kalınlığı (cm)'], ['extLenCm',2,40,0.5,'Uzatma Uzunluğu (cm)'], ['extGapCm',0.2,5,0.1,'Parça Boşluğu (cm)'], ['dimPlaneOffsetCm',1,100,0.5,'Flanştan Mesafe (cm)'], ['labelOffsetCm',0,5,0.1,'Etiket Ofset (cm)'] ].forEach(p=>add(F2,P,p[0],p[1],p[2],p[3],p[4]));

const F3=gui.addFolder('Renkler');
[ ['colorW1','W1 Rengi'], ['colorH1','H1 Rengi'], ['colorW2','W2 Rengi'], ['colorH2','H2 Rengi'], ['colorL','L Rengi'], ['colorES','ES Rengi'] ].forEach(p=>F3.addColor(P,p[0]).name(p[1]).onChange(build));

const FA=gui.addFolder('Alan Hesabı');
FA.add(P,'areaIncludeFlange').name('Flanşı dahil et').onChange(build);
FA.add(P,'wastePercent',0,100,1).name('% Atık/Pay').onChange(build);
FA.add(P,'kFactor',0,2,0.01).name('Düzeltme Katsayısı k').onChange(build);

// === Döngü ===
addEventListener('resize',()=>{ Cam.aspect=innerWidth/innerHeight; Cam.updateProjectionMatrix(); R.setSize(innerWidth,innerHeight); LBL.setSize(innerWidth,innerHeight); });
(function anim(){ requestAnimationFrame(anim); Ctrl.update(); R.render(S,Cam); LBL.render(S,Cam); })();
</script>
<script src="./js/child-bridge.js"></script>
<script> window.P = window.P || P; </script>
</body></html>
